@ Object class (toString, equals, hashCode, clone, finalize)
- 자바의 모든 클래스의 최상위 클래스
- java.lang.Object class
- 컴파일러가 extends Object를 넣어준다.
- 모든 클래스는 Object 클래스의 일부 메서드를 재정의해 사용 가능(final 메소드 제외)

Object->F1->Help->Java API

# toStrign()
우클릭-src-overriding
toString() 오버라이딩 가능

- 원형:
getClass().getName() + '@' + Integer.toHexString(hashCode())

# eqauls()
: 두 개의 객체가 동일한지?
: Lee.equals(Shin) = (Lee == Shin)
: 물리적으로 다른 메모리에 위치한 객체라도 논리적으로 동일함을 구현하기 위해 재정의하는 경우가 같다.

# hashCode()
- 자바의 JVM가 인스턴스가 생성했을 때 주는 메모리 주소값을 해쉬코드라고 한다.
- hashCode() : 인스턴스가 저장된 가상머신의 주소를 10진수로 반환

# equals() 가 true인 경우
1) 논리적으로 두 객체가 동일한 경우
(실제적인 메모리 주소는 달라도 이름과 학번이 같은 객체)
2) hashCode() 의 값이 같은 경우
(원래는 메모리주소값을 반환하지만 재정의되어있는 경우가 있다. Integer i1 = 100; Integer i2 = 200; i1.hashCode() 와 i2.hashCode() 가 같다)
--> equals()를 재정의했다면 보통 hashCode() 도 재정의한다.

# 그렇다면 실제 메모리 주소를 확인하려면?
- hashCode()는 재정의 될 수 있기 때문에 늘 메모리 주소값을 반환한다고 보장할 수 없다.
- System.identifyHashCode(i1) 을 사용하면 된다.


# clone()
- 기본틀로부터 같은 속성값을 가진 객체의 복사본 생성
- 정보은닉에 위배 될 가능성(private 변수를 그대로 복사해오는 경우 등)이 있으므로 복제할 객체는 cloneable 인터페이스를 명시해야 한다

class Book implements Cloneable { ... }
Book book2 = (Book)book.clone();

# finalize()
- 우리가 직접 부르는 메소드가 아니고 인스턴스가 해제될 때 가비지 컬렉터에 의해서 수행되는 메소드.
- 주로 하는 일은 리소스의 해제나 혹시 닫히지 않았을 소켓을 닫는 등의 일이 수행된다

//

@ String, Wrapper 클래스

# String
String str1 = new String("abc")
String str2 = new String("abc")
str1 == str2 -> false
힙 메모리에 메모리를 할당하고 str1이 그 메모리 주소를 가리킨다

String str3 = "abc"
String str4 = "abc"
str3 == str4 -> true
숫자나 문자열이 쓰일 때 매번 쓸 때마다 다른 값이 들어오는게 아니고 상수풀이란게 있어서 상수풀에서 필요한 리터럴을 가져다 쓴다는 것.

String은 immutable하다.
(한번 선언되거나 생성된 문자열은 변경할 수 없다)
(concat하는 경우는 새로운 문자열이 생성되는 것)

-> StringBuilder, StringBuffer를 사용한다.
가변적인 char[] 배열을 멤버변수로 가지고 있는 클래스
문자열을 변경하거나 연결하는 경우 사용히면 편리.
StringBuffer는 멀티쓰레드프로그래밍에서 동기화가 보장된다. 단일 쓰레드 프로그래밍에서는 StringBuilder를 사용하는 것이 좋음.
toString() 으로 String 반환

String java = new String("java");
StringBuilder buffer = new StringBuilder(java);
buffer.append("android");
java = buffer.toString();

문자열을 연결하는 경우 문자열의 주소가 계속 바뀌지만 StringBuilder/Buffer 의 경우 주소가 항상 같다.

# Wrapper 클래스
boolean -> Boolean
byte -> Byte
char -> Character
short -> Short
int -> Integer
long -> Long
float -> Float
double -> Double

//

@ 컬렉션 프레임워크 - 제네릭 프로그래밍
자바에서 여러 자료구조와 알고리즘을 구현해놓은 라이브러리.
ArrayList, 배열, 링크드리스트가 구현되어있는 라이브러리.

이전에 제네릭 프로그래밍 방식을 배우면 좋다.
C++ 의 템플릿과 유사한 방식

변수를 선언할 때 데이터 타입을 명시해서 사용하는데 어떤 변수가 여러 타입으로 변형되어 사용될 수 있는 경우 제네릭 프로그래밍 방식을 사용한다.

컴파일러가 실제 사용되는 참조 자료형으로 변환시키기 때문에 안정적이다.

public class GenericPrinter<T> {
    private T material;
    ....
}
// 제네릭 클래스, 자료형 매개변수 T

public static void main() {
   GenericPrinter<Powder> powderPrinter = new GenericPrinter<>();
   // <> 연산자 안에 자료형을 쓰지 않아도 컴파일러가 넣어준다.

   GenericPrinter printer = new GenericPrinter();
   // 아예 타입을 안 쓸수도 있다.
   // T 를 Object 타입으로 처리한다.
}

// 특정 클래스를 상속받은 클래스만 자료형 매개변수로 쓰는 방법
// Material 을 상속받은 클래스만 자료형 매개변수로 쓸 수 있다.
// 원래 material 변수는 Object의 메소드만 사용했지만 extends 를 사용하므로써 Material 의 메소드도 사용 가능해진다.
public class GenericPrinter<T extends Material> {
    private T material;
    ....
}

제네릭 메서드
- 메서드의 매개 변수를 자료형 매개변수로 사용하는 메서드
- 메서드 내에서의 자료형 매개변수는 메서드 내에서만 유효하다(지역변수 같은 개념)
- Shape 의 T 와 makeRectangle 의 T는 다른 의미

public class Shape<T> {
   public static <T, V> double makeRectangle(Point<T, V> p1, Point<T, V> p2) {
      ...
      return width * height;
   }
}

//

@ 컬렉션 프레임워크

컬렉션 프레임워크란?
프로그램 구현에 필요한 자료구조와 알고리즘을 구현해 놓은 라이브러리
java.util 패키지에 구현되어 있다.
Collection 인터페이스와 Map 인터페이스로 구성되어있다.

Collection: 하나의 객체
Map: Key, Value 한 쌍의 데이터를 다룬다.

Collection Interface (객체 집합)
[1] List
   - ArrayList, Vector, LinkedList
[2] Set
   - HashSet, TreeSet

Map (키 밸류 집합)
[1] HashTable - Properties
[2] HashMap
[3] TreeMap

//

@ 컬렉션 프레임워크 - List 인터페이스

List 인터페이스
- Collection 하위 인터페이스
- ArrayList, Vector, LinkedList

ArrayList, Vector
- 객체 배열 클래스
- Vector는 멀티쓰레드 프로그램에서 동기화를 지원
- 동기화: 두 개의
- capacity: 요소를 넣을 수 있는 전체 공간의 크기
- size: 몇개의 요소가 들어가있는가?
- 동기화: 두 개의 쓰레드가 동시에 하나의 리로스에 접근할 때 순서를 맞춰서 데이터에 오류가 생기는 것을 방지한다.

ArrayList, LinkedList
- 순차적 구조를 구현한 클래스
- ArrayList 는 배열을 구현한 클래스, 논리적 순서와
물리적 순서가 동일, 탐색이 빠르다. O(1)
- LinkedList: 다음 요소에 대한 주소값을 가지고 있고 추가나 삭제가 쉽다.

[ex]
LinkedList<String> myList = new LInkedList<String>();
myList.add("A");
System.out.println(myList); // toString() 이 오버라이딩 되어있다.
myList.add(0, "B");

for(int i=0; i<myList.size(); i++) {
   String str = myList.get(i); // list 에만 있다. set interface에는 없다.
   System.out.println(str);
}

//

@ 컬렉션 프레임워크 - Set

Iterator 로 순회하기
- get() 없음
- Collection 의 개체를 순회하는 인터페이스

HashSet<String> set = new HashSet<String>();
set.add("ㄱㄱㄱ");
set.add("ㄴㄴㄴ");
set.add("ㄷㄷㄷ");
set.add("ㄱㄱㄱ");

System.out.println(set);
-> ㄱㄱㄱ는 한번만 들어간다.
-> 만약에 ArrayList 였다면 ㄱㄱㄱ 두번 들어간다. 중복 허용

Iterator ir = set.iterator();
(Iterator<String> ir = set.iterator(); 도 가능)

while(ir.hasNext()) {
   String str = ir.next();
   System.out.println(str);
}


[ex]
public class MemberHashSet {
   private HashSet<Member> hashSet;

   public MemberHashSet() {
      hashSet = new HashSet<Member>();
   }

   public void addMember(Member member) {
      hashSet.add(member);
   }

   public boolean removeMember(int memberId) {
      // 이 때 iterator 사용한다!
      Iterator<Member> ir = hashSet.iterator();
      while(ir.hasNext()) {
         Member member = ir.next();
         if( member.getMemberId() == memberId) {
            hashSet.removee(member);
            return true;
         }
         return false;
      }
   }

  public void showAllMember() {
      for (Member member : hashSet) {
         System.out.println(member);
      }
   }
}

main() {
   MemberHashSet manager = ... ;
   memeber.addMember(new Member(1, "ㄱㄱ"));
   memeber.addMember(new Member(2, "ㄴㄴ"));
   memeber.addMember(new Member(1, "ㄱㄱ2"));
}
여기서는 id 1 로 ㄱㄱ, ㄱㄱ1 이 둘 다 들어가버린다.
물리적으로 두 객체가 다른 객체이기 때문에

한 id 당 하나의 멤버만 존재하게 하려면
관리할 객체가 논리적으로 같다는 것이 무엇인지
equals(), hashCode() 를 재정의해야 한다


public class MemberHashSet {
   ...

   @Override
   public int hashCode(){
      return.memberId;
   }

   @Override
   public boolean equals(Object obj) {
      if (obj instanceof Member) {
         Member member = (Member)obj;
         return (this.memberId == member.memberId);
      }
      return false;
   }
}

다시 main() 을 Run 해보면 중복된 아이디로 멤버가 두개 들어가지 않음을 볼 수 있다.


//

@ 컬렉션 프레임워크 - TreeSet 인터페이스

TreeSet
- 객체의 정렬에 사용되는 클래스
- 주로 정렬, 검색에 사용된다.
- 중복 허용 X, 오름차순이나 내림차순으로 객체 정렬
- 내부적으로 이진 검색 트리로 구현되어있다.
- 이진 검색 트리에 자료가 저장될 때 비교하여 저장될 위치를 정함
- 객체 비교를 위해 Comparable 이나 Comparator 인터페이스를 구현해야 한다.

main(){
   TreeSet<String> treeSet = new TreeSet<>();
   treeSet.add("ㄱㄱㄱ");
   treeSet.add("ㄴㄴㄴ");
   treeSet.add("ㄷㄷㄷ");
   for (String str : treeSet) {
      System.out.println(str);
   }
}
// ㄱㄱㄱ, ㄴㄴㄴ, ㄷㄷㄷ 순서대로 출력됨
// String 이 Comparable 인터페이스를 이미 구현했기 때문

[ex]
회원의 id 순서대로 정렬을 해보자.
public class MemberHashSet {
   private TreeSet<Member> treeSet;

   public MemberHashSet() {
      treeSet = new TreeSet<Member>();
   }

   public void addMember(Member member) {
      treeSet.add(member);
   }

   public boolean removeMember(int memberId) {
      Iterator<Member> ir = treeSet.iterator();
      while(ir.hasNext()) {
         Member member = ir.next();
         if( member.getMemberId() == memberId) {
            treeSet.remove(member);
            return true;
         }
         return false;
      }
   }

   public void showAllMember() {
      for (Member member : treeSet) {
         System.out.println(member);
      }
   }
}

main() {
   MemberHashSet manager = ... ;
   memeber.addMember(new Member(3, "ㄱㄱ"));
   memeber.addMember(new Member(1, "ㄴㄴ"));
   memeber.addMember(new Member(2, "ㄷㄷ"));
}

TreeSet 을 멤버변수로 가지고 있다.
이대로 실행해보면 에러가 난다.
Member 클래스가 Comparable 을 구현해야 함.

public class Member implements Comparable<Member>{
   ...
   @Override
   public int compareTo(Member member) {
      return (this.memberId - member.memberId);
   }
   // return 값이 양수면 오름차순 정렬
   // return 값이 음수면 내림차순 정렬
}
// 이미 String 클래스에 compareTo 가 재정의되어있음
// return this.memberName.compareTo(member.memberName);
// 으로도 가능하다.


Comparable, Comparator 인터페이스
- 정렬 대상이 되는 클래스가 구현해야 한다.
- Comparable: compareTo(v1);
this와 매개변수를 비교
- Comparator: compare(v1, v2);
두 개의 매개변수를 비교
TreeSet 생성자에 Comparator가 구현된 객체를 매개변수로 전달
TreeSet<Member> treeSet = new TreeSet<Member>(new Member());
- 일반적으로 Comparable 더 사용
- 이미 Comparable이 구현되어있는 경우 Comparator를 이용해 다른 정렬 방식을 정의할 수 있다.

[ex]
class MyCompare implements Comparator<String> {
   @Override
   public intcompare(String s1, String s2) {
      return s1.compareTo(s2) * (-1);
   }
}

main() {
   TreeSet<String> treeSet = new TreeSet<String>(new MyCompare());
}

스트링 내림차순으로 정렬하는 Set 이 만들어진다.

//

@ Map 인터페이스
- 키 밸류 페어 객체를 관리하는데 필요한 메소드가 정의됨
- 키는 중복 불가능
- 검색을 위한 자료 구조
- 키를 이용해서 값을 저장, 검색, 삭제
내부적으로 hash 방식으로 구현됨
index = hash(key)
- 키가 되는 객체는 객체의 유일성함을 알기 위해 equals(), hashCode() 메소드를 재정의한다.

# HashMap 클래스
- Map 인터페이스를 구현한 클래스

# TreeMap 클래스
- 키에 사용되는 클래스에 Comparable, Comparator 인터페이스 구현
: 구현된 클래스를 키로 사용하는 경우는 구현할 필요 없음(키로 Integer를 쓰는 경우 등)

public final class Integer extends Number implements Comparable<integer> {
    public int compareTo(Integer anotherInteger) {
        return compare(this.value, anotherInteger.value);
    }
}

hash?
학생 1~100을 의자 20개에 앉혀야 함.
학생 id 를 20로 나눴을 때 나머지를 의자 번호에 매칭함
5, 25, 45 는 모두 5번 의자에 앉게 된다.

//

@ 내부 클래스
- 내부에서 사용하기 위한 클래스
- 주로 외부 클래스 생성자에서 내부 클래스 생성
- 인스턴스 내부 클래스, 정적 내부 클래스, 지역 내부 클래스, 익명 내부 클래스


//

@ 내부 클래스 (익명 이너 클래스,

class Outer {
  int outNum = 100;
  static int sNum = 200;

  Runnable getRunnable(int i) {
    int num = 100;
    class MyRunnable implements Runnable {
      @Override
      public void run() {
        num += 10;
        i = 200;
        System.out.println(num);
        System.out.println(i);
        System.out.println(outNum);
        System.out.println(Outer.sNum);
      }
    }
    return new MyRunnable();
  };
  // 바깥 클래스의 메소드 안에서 내부 클래스 선언
  // 이 경우 num, i 는 지역변수가 되고 안에서 final로 바뀜
  // 따라서 10을 더하거나 값을 변경할 수 없다.
  // 단 참조는 가능
}

psvm(String[] args){
  Outer outer = new Outer();
  Runnable runnable = outer.getRunnable(50);

  runnable.run():
  runnable.run():
  runnable.run():
}

50이 i로 들어감. i는 지역변수로 getRunnable()이
끝나면 사라진다.

getRunnable()이 종료되더라도
run() 은 언제든지 호출 될 수 있기 때문에
getRunnable()안에서 i, num 을 변경, 수정할 수 없게 되어야 해서 final로 만들어 버림.

MyRunnable 클래스의 이름은 쓸 일이 없다.
익명 클래스를 리턴하는 걸로 바꿔 써도 똑같다.

class Outer {
  int outNum = 100;
  static int sNum = 200;

  Runnable getRunnable(int i) {
    int num = 100;
    return new Runnable() {
      @Override
      public void run() {
        num += 10;
        i = 200;
        System.out.println(num);
        System.out.println(i);
        System.out.println(outNum);
        System.out.println(Outer.sNum);
      }
    }
  };

  Runnable runner = new Runnable(){
      @Override
      public void run() {
        System.out.println("test");
      }
  };
}

익명 내부 클래스. 바로 인터페이스나 추상 클래스의 생성을 할 수 있다.(원래는 인터페이스나 추상클래스를 상속받은 클래스를 만들고 그 클래스를 생성해서 썼는데 단 하나의 인터페이스나 단 하나의 추상 클래스의 경우는 클래스 이름 없이 바로 new 키워드를 이용해서 생성할 수 있다.)

psvm(String[] args){
  Outer outer = new Outer();
  outer.runner.run();
}

//

@ 람다식
- 자바에서 함수형 프로그래밍을 구현하는 방식
(함수 베이스로 프로그래밍을 함. 매개변수를 받아 사용하고 외부변수를 사용하지 않음. 순수함수라고 함. 외부변수를 사용하지 않기 때문에 외부에 사이드이펙트를 주지 않음. 이 함수 내에서 다른 외부의 값이 변하지 않기 때문에. 병렬 처리가 가능하다)
- 함수형 인터페이스를 선언함

# 함수형 프로그래밍이란?
- 순수함수를 구현하고 호출
- 입력 받은 자료를 기반으로 수행되고 외부에 영향을 미치지 않기 때문에 병렬적으로 처리할 수 있다.

# 람다식 문법
메소드 이름이 없음,
1) 매개 변수가 하나인 경우 괄호 생략 가능
두개인 경우 괄호 생략 불가능
str -> {sout(str);}

2) 중괄호 안의 구현부가 한 문장이 경우 중괄호 생략
str -> sout(str);

3) 중괄호 안의 구현부가 한 문장이라도 return 문은 중괄호를 생략할 수 없다.
str -> return str.length();

4) 중괄호 안의 구현부가 반환문 하나라면 return과 중괄호를 모두 생략할 수 있음
(x,y)->x+y;
str->str.length()


# 함수를 변수처럼 사용하는 람다식
프로그램에서 변수는
(1) 자료형에 기반하여 선언 (int a;)
(2) 매개변수로 전달하고 (int add(int x, int y);)
(3) 메서드의 반환 값으로 사용 (return num;)
>>>  람다식은 프로그램 내에서 변수처럼 사용 가능하다.


[실습 1]
@FunctionalInterface
public interface MyMaxNumber {
  int getMaxNumber(int x, int y);
}
1) @FunctionalInterface 를 붙인 인터페이스 형태
2) 메소드는 단 한개만 가지고 있어야 한다.

void main() {
  MyMaxNumber max = (x,y)->(x>=y)?x:y;
  sout(max.getMaxNumber(10,20));
}
// 중괄호 안의 구현부가 반환문 하나라면 return과 중괄호를 모두 생략할 수 있음

[실습 2]
interface StringConcat {
    void makeString(String s1, String s2);
}

class StringConImpl implements StringConcat {
    @Override
    void makeString(String s1, String s2) {
        sout(s1 + ", " + s2);
    }
}

class TestStringConcat {
  psv main() {
    StringConImpl impl = new StringConImpl();
    impl.makeString("hello", "world");

    StringConcat concat = (s, v)->sout(s + ", " +v);
    concat.makeString("hello", "world");

    StringConcat concat2 = new StringConcat() {
      public void makeString(String s1, String s2) {
        sout(s + ", " + v);
      }
    }
    concat2.makeString("hello", "world");
  }
}

[실습 3]
interface PrintString {
  void showString(String str);
}
public class TestLambda {
  psv main() {
    PrintString lambdaStr = s->sout(s);
    (1) 함수의 구현부가 대입 (변수에 대입되듯이)
    lambdaStr.showString("test");

    showMyString(lambdaStr);
    (2) 매개변수로 람다식이 전달됨

    PrintString test = returnString();
    test.showString("test3");
  }
  psv showMyString(PrintString p) {
    p.showString("test2");
  }
  ps PrintString returnString() {
    return s->sout(s);
    (3) 리턴값으로 람다식을 리턴 가능
  }
}

//

@ 스트림
- 자료의 대상과 관계없이 동일한 연산을 수행할 수 있는 기능(자료의 추상화)
- 배열, 컬렉션에 동일한 연산이 수행되어 일관성 있는 처리 가능
- 한번 생성하고 사용한 스트림은 재사용할 수 없음
- 스트림 연산은 기존 자료를 변경하지 않음
- 중간 연산과 최종 연산으로 구분됨
- 최종 연산이 수행되어야 모든 연산이 적용되는 지연 연산

# 스트림 연산 - 중간 연산
1) 스트림 생성: stream()
2) 중간 연산: filter(), map()
3) 최종 연산: forEach(), count(), sum(), ...

sList.stream()
    .filter(s->s.length()>=5)
    .forEach(s->sout(s));

customerList.stream()
    .map(c->c.getName())
    .forEach(s->sout(s));

# reduce() 연산
- 정의된 연산이 아닌 프로그래머가 직접 연산을 정의할 때
- 최종 연산으로 스트림의 요소를 소모하며 연산 수행

Arrays.stream(arr).reduce(0, (a,b)->a+b));
0: 초기값, 배열의 모든 요소의 합을 구한다.


[실습 1]
class IntArrayTest {
  psv main() {
    int[] arr = {1,2,3,4,5};
    int sum = Arrays.stream(arr).sum();
    int count = (int) Arrays.stream(arr).count();
  }
}

class ArrayListStreamTest {
  psv main() {
    List<String> sList = new ArrayList<String>();
    sList.add("A"); ("B"); ("C");

    Stream<String> stream = sList.stream();
    stream.forEach(str -> sout(str));

    sList.stream().sorted().forEach(s->sout(s));
    // Stream 은 comparable 이 구현되어 있기 때문에 sorted() 가능

    sList.stream().map(s->s.length()).forEach(len->sout(len));
  }
}


[실습 2]
String[] greetings
   = {"안녕하세요~~~", "hello" "Good morning", "반갑습니다."};
String longestStr =
  Arrayas.stream(greetings).reduce("", (s1, s2)->
  {
    if(s.getBytes().length >= s2.getBytes().length) return s1;
    else return s2;
  });
sout(longestStr);

한글은 2바이트이므로 getBytes() 후 비교하자.


[실습 3]
class CompareString impl BinaryOperator<String>{
  @Override
  public String apply(Str s1, Str s2) {
    if(s1.getBytes().length >= s2.getBytes().length) return s1;
    else return s2;
  }
}

String[] greetings
  = {"안녕하세요~~~", "hello" "Good morning", "반갑습니다."};
String longestStr =
  Arrayas.stream(greetings).reduce(new CompareString()).get());


//

@ 예외

# 오류란?
[1] 컴파일 오류:
프로그램 코드 작성 중 발생하는 문법적 오류
[2] 실행 오류:
실행중인 프로그램이 의도하지 않은 동작을 하거나(bug) 프로그램이 중지되는 오류(runtime error)

자바는 예외처리를 통해 프로그램의 비정상 종료를 막고 log를 남길 수 있다.

# 오류와 예외 클래스
[1] 시스템 오류(error):
가상 머신에서 발생, 프로그래머가 처리할 수 없음
동적 메모리를 다 사용한 경우, stack over flow(계속 재귀처리해서 이 쓰레드가 사용할 수 있는 스택 메모리가 바닥난 경우)

[2] 예외(Exception):
프로그램에서 제어할 수 있는 오류
읽으려는 파일이 없는 경우, 네트웍이나 소켓 연결 오류 등 자바 프로그램에서는 예외에 대한 처리를 수행함

Exception
[+] IOException
-----[+] FileNotFoundException
-----[+] SocketException
[+] RuntimeException
-----[+] ArithmeticException
-----[+] IndexOutofBoundsException

# try - catch - finally
try {
  // ...
} catch(Exception e) {
  // ...
} finally {
  // ...
}

# try-catch-resources 문
- 리소스를 자동으로 해제하도록 제공해주는 구문
- 해당 리소스가 AutoCloseable을 구현한 경우 close()를 명시적으로 호출하지 않아도 try{} 블록에서 오픈된 리소스는 정상적인 경우나, 예외 상황 모두 자동으로 close() 호출됨
- Java 7
- FileInputStream implements AutoCloseable
- 자바 9 이전에서는 try 문에서 리소스 객체를 생성하면 자동으로 close() 가 호출된다.
- 자바 9 부터는 외부에서 선언한 변수를 try 문에 그대로 써도 된다.
AutoCloseObj obj = new AutoCloseObj();
try(obj) {
  // ...
} catch(Exception e) {
  // ...
}

# 예외 처리 미루기
- throws 를 사용해서 예외처리 미루기
- try{} 블록으로 예외를 처리하지 않고, 메서드 선언부에 throws 를 추가
- 예외가 발생한 메서드에서 예외 처리를 하지 않고 이 메서드를 호출한 곳에서 예외 처리를 하겠다.
- main() 에서 throws 를 사용하면 가상머신에서 처리된다.

# 다중 예외 처리하기
- 하나의 try{} 에서 여러 예외가 발생하는 경우 catch{} 한 곳에서 처리하거나 여러 catch{} 에서 나눠서 처리할 수 있다.
- 가장 최상위 클래스인 Exception 클래스는 가장 마지막 catch{} 에서 처리해야 한다.

# 사용자 정의 예외
- throw 키워드로 예외를 발생 시킴
ex) 아이디가 null이거나 8이하 20자 이상인 경우 예외


[실습 1]
pvs main() {
    int[] arr = new int[5];
    try {
      for(int i=0; i<=5; ++i) {
        sout(arr[i]);
      }
    } catch(ArrayIndexOutofBoundsException e) {
      sout(e);
    }
}
예외가 발생했지만 예외처리가 되어 있어서 서버가 죽지 않음.


[실습 2]
main() {
    FileInputStream fis = null;
    try {
      fis = new FileInputStream("a.txt");
      return;
    } catch (FileNotFoundException e) {
      sout(e);
    } finally {
      fis.close(); // 얘도 try, catch 감싸긴 해야 함
    }
    sout("end");
}
return; 되어도 finally { } 는 수행된다.
단 sout("end")는 불리지 않는다.


[실습 3]
try(FileInputStream fis = new FileInputStream("a.txt")) {
    // ...
} catch (FileNotException e) {
    // ...
} catch (IOException e) {
    // ...
}

[실습 4]
public Class loadClass(Str fileName, Str className)
    throws FileNotFoundEx, ClassNotFoundEx
{
    FileInputStream fis = new fileInputStream(fileName);
    Class c = Class.forName(className);
    return c;
}

main() {
  ThrowsException test = new ThrowsException();
  try {
    test.loadClass("b.txt", "java.lang.String");
  } catch (FileNotFoundExceptione e) {
    // ...
  } catch (ClassNotfoundException e) {
    // ...
  }
}
loadClass() 는 throws를 사용해서 에외처리를 미루고, 얘를 호출한 곳에서 try-catch 문을 사용해서 예외처리를 하고 있다.


[사용자 정의 예외]
public class IDFormatException extends Exception {
  public IDFormatException(String message) {
    super(message);
}}

public void setUserID(Str userID) throws IDFormatException {
  if(userID == null)
    throw new IDFormatException("null 에러");
  else if(userID.length() < 8 || userID.length() > 20)
    throw new IDFormatException("8자 이상 20자 이하");

  this.id = userID;
}
main() {
  try {
    idTest.setUserID(null);
  } catch (IDFormatException e) {
    sout(e);
}}